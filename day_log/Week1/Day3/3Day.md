<aside>
💡 구름톤 챌린지 3일차

</aside>

### 문제

---

보통의 계산기는 한 번에 하나의 계산 결과만 나타낼 수 있다. 그래서 여러 개의 계산 결과가 필요한 경우에는 이전 계산 결과를 따로 기록해 둬야 하는 번거로움이 있었다.

플레이어는 이러한 점을 해결하기 위해서 합 계산기를 만들었다. 합 계산기는 여러 개의 계산식을 입력받은 뒤, 각각의 계산 결과를 모두 합해서 출력하는 기능을 가지고 있다. 합 계산기에 입력할 수 있는 계산식은 아래 조건을 만족해야 한다.

- 계산식은 `<정수> <연산 기호> <정수>` 형태이다.
- `<연산 기호>` 에는 더하기, 빼기, 곱하기, 나누기의 네 가지 사칙 연산 기호가 들어갈 수 있다. 이때, 나눗셈 결과의 나머지는 버린다.

합 계산기에 입력할 **T**개의 계산식이 주어질 때, 합 계산기의 출력 결과를 구해보자..

### 정답 코드

---

```java
import java.io.*;

class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()); 

        int d = 0;

        for (int i = 0; i < n; i++) {
            String[] input = br.readLine().split(" ");
            int a = Integer.parseInt(input[0]);
            int c = Integer.parseInt(input[2]);

            if (input[1].equals("+")) {
                d += a + c;
            } else if (input[1].equals("-")) {
                d += a - c;
            } else if (input[1].equals("*")) {
                d += a * c;
            } else if (input[1].equals("/")) {
                if (c != 0) {
                    d += a / c;
                } else {
                  
                    return;
                }
            }
        }

        System.out.println(d);
    }
}
```

### 문제 풀이

---

1. **`N`**개의 연산을 처리하기 위해 **`for`** 반복문을 사용합니다. 이 반복문은 사용자가 입력한 연산의 개수인 **`N`**번 반복됩니다.
2. **`br.readLine().split(" ")`**을 통해 사용자로부터 입력을 받고 공백을 기준으로 입력 값을 분할하여 **`input`** 배열에 저장합니다.
3. **`input`** 배열의 첫 번째 요소(**`input[0]`**)는 숫자 **`a`**의 값이고, 세 번째 요소(**`input[2]`**)는 숫자 **`c`**의 값입니다.
4. **`input[1]`**은 두 숫자를 어떻게 연산할지 나타내는 연산자입니다. **`if`** 조건문을 사용하여 연산자를 판별하고, 해당 연산을 수행합니다.

이렇게 코드는 입력된 연산자에 따라 숫자 **`a`**와 **`c`**를 적절하게 계산하고, 그 결과를 변수 **`d`**에 누적하여 최종 계산 결과를 얻습니다.

### 어려웠던 점

---

1. **사용자 입력 처리**: 사용자로부터 입력을 받고 파싱하는 부분은 항상 복잡하고 실수하기 쉽습니다. 특히, 입력 값에 대한 예외 처리를 추가해야 하는데, 이 부분에서 어려움을 겪을 수 있습니다.
2. **연산자 처리**: 사용자가 입력한 연산자(**`+`**, **``**, **``**, **`/`**)에 따라 적절한 계산을 수행하는 부분은 코드의 핵심입니다. 올바른 연산을 수행하기 위해 조건문을 사용하고, 각 연산자에 따른 처리를 구현하는 것은 복잡할 수 있습니다.
3. **오류 처리**: 0으로 나누는 경우와 같은 예외 상황을 처리하는 것은 중요합니다. 오류를 적절하게 처리하려면 코드가 예외 상황을 식별하고 사용자에게 이를 알려야 합니다.
4. **가독성과 주석**: 코드를 다른 사람이 이해하기 쉽도록 만들기 위한 주석과 가독성 개선은 중요한 과제입니다. 코드를 작성할 때 주석을 추가하고, 변수와 함수의 이름을 명확하게 지정하여 코드를 더 읽기 쉽게 만들 수 있습니다.
5. **프로그램 흐름 이해**: 코드의 전체적인 흐름을 이해하는 것은 처음에 어려울 수 있습니다. 어떤 부분이 언제 실행되는지, 변수들이 어떻게 상호작용하는지를 이해하기 위해 디버깅과 코드 분석이 필요할 수 있습니다.

이러한 어려움들은 프로그래밍 경험이 쌓이면서 점점 극복할 수 있게 됩니다. 코드를 작성하고 디버깅하는 과정에서 발생하는 어려움들은 프로그래머로서 성장하는 중요한 부분입니다.

### 배웠던 점 **`equals` 메서드**

---

**`equals`** 함수는 자바에서 객체 간의 동등성 비교를 수행하기 위해 사용되는 메서드입니다. 이 함수는 모든 객체 클래스에서 상속받은 **`Object`** 클래스의 메서드 중 하나로, 객체의 내용이 같은지를 비교합니다. 아래는 **`equals`** 함수의 설명을 마크다운 형식으로 나타낸 것입니다:

### **`equals` 메서드**

### 기능

**`equals`** 메서드는 객체의 내용이 같은지를 비교하여 두 객체가 동등한지 여부를 판단합니다. 객체의 동등성은 주로 두 객체의 필드 값이 같은지를 확인하여 결정됩니다.

### 사용 방법

**`equals`** 메서드는 일반적으로 다음과 같이 사용됩니다:

```java
public boolean equals(Object obj) {
    // 객체 내용을 비교하는 로직
    // 반환값은 두 객체가 동등하면 true, 아니면 false
}
```

- **`Object obj`**: 비교할 대상 객체를 인자로 받습니다.

### 반환 값

- **`boolean`**: 두 객체가 내용이 같으면 **`true`**를 반환하고, 다르면 **`false`**를 반환합니다.

### 예제

```java
public class Person {
    private String name;
    private int age;

    // equals 메서드 재정의
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true; // 동일한 객체인 경우 true 반환
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false; // obj가 null이거나 클래스가 다른 경우 false 반환
        }
        Person person = (Person) obj; // obj를 Person 클래스로 캐스팅
        return age == person.age && Objects.equals(name, person.name); // 필드 값 비교
    }

    // hashCode 메서드도 함께 재정의하는 것이 좋음
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

위 예제에서는 **`Person`** 클래스에서 **`equals`** 메서드를 재정의하여 객체의 **`name`**과 **`age`** 필드 값을 비교하도록 구현하였습니다. 또한 **`hashCode`** 메서드도 함께 재정의하여 동등한 객체에 대해 동일한 해시 코드를 반환하도록 구현합니다.

### 주의 사항

- **`equals`** 메서드를 재정의할 때는 두 객체의 동등성을 결정하는 로직을 구현해야 합니다. 이 로직은 주로 객체의 필드 값을 비교하여 정의됩니다.
- **`equals`** 메서드를 재정의할 때는 반드시 **`hashCode`** 메서드도 함께 재정의해야 합니다. 두 메서드의 동작을 일관되게 유지해야 합니다.
- **`null`**을 비교 대상으로 넘기지 않도록 주의해야 합니다. **`equals`** 메서드 내에서 **`null`** 체크를 포함시켜야 합니다.

**`equals`** 메서드를 적절히 재정의하면 객체 간의 내용 비교를 통해 동등성을 판단할 수 있으며, 이것은 자바에서 객체 비교와 컬렉션에서 객체를 관리할 때 중요한 역할을 합니다.